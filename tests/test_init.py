# Copyright 2025 Ben Mensi
# SPDX-License-Identifier: Apache-2.0

"""Tests for init command."""

from pathlib import Path

import yaml
from typer.testing import CliRunner

from life.cli import app

runner = CliRunner()


class TestInit:
    """Test init command."""

    def test_init_creates_config(self, tmp_path, monkeypatch):
        """Test that init creates .life/config.yml."""
        # Change to temp directory
        monkeypatch.chdir(tmp_path)

        result = runner.invoke(app, ["init"])

        assert result.exit_code == 0
        assert "Initialized Life-CLI project" in result.stdout

        # Check directory created
        config_dir = tmp_path / ".life"
        assert config_dir.exists()
        assert config_dir.is_dir()

        # Check config file created
        config_file = config_dir / "config.yml"
        assert config_file.exists()

        # Check config content
        with open(config_file) as f:
            config = yaml.safe_load(f)

        assert "workspace" in config
        assert config["workspace"] == str(tmp_path)
        assert "today" in config
        assert "sync" in config
        assert "merge" in config
        assert "process" in config
        assert "status" in config

    def test_init_with_workspace_option(self, tmp_path, monkeypatch):
        """Test init with custom workspace path."""
        monkeypatch.chdir(tmp_path)
        workspace_path = tmp_path / "my-workspace"

        result = runner.invoke(app, ["init", "--workspace", str(workspace_path)])

        assert result.exit_code == 0

        config_file = tmp_path / ".life" / "config.yml"
        with open(config_file) as f:
            config = yaml.safe_load(f)

        assert config["workspace"] == str(workspace_path.resolve())

    def test_init_fails_if_already_initialized(self, tmp_path, monkeypatch):
        """Test init fails gracefully if config already exists."""
        monkeypatch.chdir(tmp_path)

        # First init succeeds
        result1 = runner.invoke(app, ["init"])
        assert result1.exit_code == 0

        # Second init fails
        result2 = runner.invoke(app, ["init"])
        assert result2.exit_code == 1
        assert "already initialized" in result2.stdout

    def test_init_force_overwrites_existing(self, tmp_path, monkeypatch):
        """Test init --force overwrites existing config."""
        monkeypatch.chdir(tmp_path)

        # First init
        result1 = runner.invoke(app, ["init"])
        assert result1.exit_code == 0

        # Modify config
        config_file = tmp_path / ".life" / "config.yml"
        config_file.write_text("custom: value\n")

        # Force init overwrites
        result2 = runner.invoke(app, ["init", "--force"])
        assert result2.exit_code == 0

        with open(config_file) as f:
            config = yaml.safe_load(f)

        # Custom value should be gone, default config restored
        assert "custom" not in config
        assert "workspace" in config

    def test_init_dry_run(self, tmp_path, monkeypatch):
        """Test init in dry-run mode."""
        monkeypatch.chdir(tmp_path)

        result = runner.invoke(app, ["--dry-run", "init"])

        assert result.exit_code == 0
        assert "[DRY RUN]" in result.stdout

        # Config should NOT be created
        config_dir = tmp_path / ".life"
        assert not config_dir.exists()

    def test_init_creates_header_comment(self, tmp_path, monkeypatch):
        """Test that init adds header comments to config."""
        monkeypatch.chdir(tmp_path)

        result = runner.invoke(app, ["init"])
        assert result.exit_code == 0

        config_file = tmp_path / ".life" / "config.yml"
        content = config_file.read_text()

        assert "# Life-CLI Project Configuration" in content
        assert "# Generated by: life init" in content
        assert f"# Project: {tmp_path.name}" in content

    def test_init_today_config(self, tmp_path, monkeypatch):
        """Test that init creates today-specific config."""
        monkeypatch.chdir(tmp_path)

        result = runner.invoke(app, ["init"])
        assert result.exit_code == 0

        config_file = tmp_path / ".life" / "config.yml"
        with open(config_file) as f:
            config = yaml.safe_load(f)

        assert "today" in config
        assert "daily_dir" in config["today"]
        assert "template_path" in config["today"]
        assert "notes/daily" in config["today"]["daily_dir"]
        assert "notes/templates" in config["today"]["template_path"]


class TestInitIntegration:
    """Integration tests for init command."""

    def test_init_then_today(self, tmp_path, monkeypatch):
        """Test that life today works after life init."""
        monkeypatch.chdir(tmp_path)

        # Initialize project
        result1 = runner.invoke(app, ["init"])
        assert result1.exit_code == 0

        # Use life today (dry-run to avoid creating files)
        result2 = runner.invoke(app, ["--dry-run", "today"])
        assert result2.exit_code == 0
        assert "[DRY RUN]" in result2.stdout
        assert "notes/daily" in result2.stdout

    def test_config_loading_precedence(self, tmp_path, monkeypatch):
        """Test that .life/config.yml takes precedence."""
        monkeypatch.chdir(tmp_path)

        # Create .life/config.yml
        result1 = runner.invoke(app, ["init"])
        assert result1.exit_code == 0

        # Also create life.yml (legacy)
        legacy_config = tmp_path / "life.yml"
        legacy_config.write_text("workspace: /legacy\n")

        # Verify .life/config.yml is loaded (not legacy)
        result2 = runner.invoke(app, ["config", "validate"])
        # Should load from .life/config.yml, not life.yml
        assert result2.exit_code == 0
        # Can't directly check which was loaded, but it should succeed
